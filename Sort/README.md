### 如何分析一个“排序算法”
1. 排序算法的执行效率
    1. 最好情况、最坏情况、平均
    2. 时间复杂度的系数、常数 、低阶
    3. 比较次数和交换（或移动）次数
2. 排序算法的内存消耗
    - 原地排序

3. 排序算法的稳定性
    1. 稳定的排序算法
    2. 不稳定的排序算法
    - 稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变

##### 冒泡
1. 冒泡的过程只涉及相邻数据的交换操作，空间复杂度为 O(1)，原地排序。
2. 当有相邻的两个元素大小相等的时候，不做交换，不会改变顺序，所以稳定排序算法。
3. 最好情况下，已经是有序的，一次冒泡，最好情况时间复杂度是 O(n)。
最坏的情况，刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)

##### 插入
1. 原地排序。
2. 当有相邻的两个元素大小相等的时候，后面的放在前面元素后，所以稳定排序算法。
3. 最好是时间复杂度为 O(n)。最坏情况时间复杂度为 O(n2)，平均O(n)。

##### 选择
1. 原地排序。
2. 不稳定的排序算法。选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。
3. 最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。

##### 归并
1. 不是原地排序，空间复杂度O(n)。
2. 先把前半元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。
3. 最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(nlogn)。

    T(n) = 2*T(n/2) + n
         = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
         = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
         = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
         ......
         = 2^k * T(n/2^k) + k * n
         ......

     T(n/2^k)=T(1)  ==》 k=log2n ==》 T(n)=Cn+nlog2n

##### 快排
1. 原地排序。
2. 不稳定的排序算法。
3. 如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)。
数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)