### 如何分析一个“排序算法”
1. 排序算法的执行效率
    1. 最好情况、最坏情况、平均
    2. 时间复杂度的系数、常数 、低阶
    3. 比较次数和交换（或移动）次数
2. 排序算法的内存消耗
    - 原地排序

3. 排序算法的稳定性
    1. 稳定的排序算法
    2. 不稳定的排序算法
    - 稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变

##### 冒泡
1. 冒泡的过程只涉及相邻数据的交换操作，空间复杂度为 O(1)，原地排序。
2. 当有相邻的两个元素大小相等的时候，不做交换，不会改变顺序，所以稳定排序算法。
3. 最好情况下，已经是有序的，一次冒泡，最好情况时间复杂度是 O(n)。
最坏的情况，刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)

##### 插入
1. 原地排序。
2. 当有相邻的两个元素大小相等的时候，后面的放在前面元素后，所以稳定排序算法。
3. 最好是时间复杂度为 O(n)。最坏情况时间复杂度为 O(n2)，平均O(n)。

##### 选择
1. 原地排序。
2. 不稳定的排序算法。选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。
3. 最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。

##### 归并
1. 不是原地排序，空间复杂度O(n)。
2. 先把前半元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。
3. 最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(nlogn)。

    T(n) = 2*T(n/2) + n
         = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
         = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
         = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
         ......
         = 2^k * T(n/2^k) + k * n
         ......

     T(n/2^k)=T(1)  ==》 k=log2n ==》 T(n)=Cn+nlog2n

##### 快排
1. 原地排序。
2. 不稳定的排序算法。
3. 如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)。
数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)

### 线性排序
时间复杂度是 O(n) 的排序算法：**桶排序、计数排序、基数排序**。
时间复杂度是线性的，所以我们把这类排序算法叫作线性排序（Linear sort）。
之所以能做到线性的时间复杂度，原因是，这三个算法是非基于比较的排序算法，不涉及元素之间的比较操作。
适用场景较苛刻。
##### 桶排序（Bucket sort）
1. 原理：
如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。
每个桶内部使用快速排序，时间复杂度为 O(k * logk)。
m 个桶排序的时间复杂度就是 O(m * k * logk)，
因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。
当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。
2. 要求：
    1. 要排序的数据需要很容易就能划分成 m 个桶，并且桶与桶之间有着天然的大小顺序。
    这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。
    2. 数据在各个桶之间的分布是比较均匀的。
    如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。
    在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。
3. 适用场景：桶排序比较适合用在外部排序中（外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。）
4. tip是： 针对这些划分之后还是比较大的桶，继续划分，如果划分之后，还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。

##### 计数排序（Counting sort）
1. 原理：（计数排序其实是桶排序的一种特殊情况）当要排序的 n 个数据，所处的范围并不大的时候，
比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。
要这个数据的范围较小。根据考生的成绩，我们可以分成 901 个桶，对应分数从 0 分到 900 分。
我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。
我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。
因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。
2. 要求：计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。
    而且，计数排序只能给**非负整数排序**，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

